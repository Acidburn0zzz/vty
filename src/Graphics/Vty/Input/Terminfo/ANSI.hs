module Graphics.Vty.Input.Terminfo.ANSI where

import Graphics.Vty.Input.Events

-- | Terminals augmented by the built in ANSI input mapping.
supports :: String -> Bool
supports "ansi" = True
supports _      = False

-- | Encoding for navigation keys.
nav_keys_0 :: ClassifyTable
nav_keys_0 =
    [ k "G" KCenter
    , k "P" KPause
    , k "A" KUp
    , k "B" KDown
    , k "C" KRight
    , k "D" KLeft
    , k "H" KHome
    , k "F" KEnd
    , k "E" KBegin
    ]
    where k c s = ("\ESC["++c, EvKey s [])

-- | VT 100 (?) encoding for shift, meta and ctrl plus arrows/home/end
nav_keys_1 :: ClassifyTable
nav_keys_1 =
   [("\ESC[" ++ charCnt ++ show mc++c,EvKey s m)
    | charCnt <- ["1;", ""], -- we can have a count or not
    (m,mc) <- [([MShift],2::Int), ([MCtrl],5), ([MMeta],3),
               ([MShift, MCtrl],6), ([MShift, MMeta],4)], -- modifiers and their codes
    -- directions and their codes
    (c,s) <- [("A", KUp), ("B", KDown), ("C", KRight), ("D", KLeft), ("H", KHome), ("F", KEnd)]
   ]

-- | VT 100 (?) encoding for ins, del, pageup, pagedown, home, end
nav_keys_2 :: ClassifyTable
nav_keys_2 =
    let k n s = ("\ESC["++show n++"~",EvKey s [])
    in zipWith k [2::Int,3,5,6,1,4]
                 [KIns,KDel,KPageUp,KPageDown,KHome,KEnd]

-- | VT 100 (?) encoding for ctrl + ins, del, pageup, pagedown, home, end
nav_keys_3 :: ClassifyTable
nav_keys_3 =
    let k n s = ("\ESC["++show n++";5~", EvKey s [MCtrl])
    in zipWith k [2::Int,3,5,6,1,4]
                 [KIns,KDel,KPageUp,KPageDown,KHome,KEnd]

-- | VT 100 (?) encoding for shift plus function keys
-- 
-- TODO: I suspect this should be generated by interpretting the terminals use of meta mode:
-- "If the terminal has a ``meta key'' which acts as a shift key, setting the 8th bit of any
-- character transmitted, this fact can be indicated with  km.   Other- wise,  software  will
-- assume that the 8th bit is parity and it will usually be cleared.  If strings exist to turn this
-- ``meta mode'' on and off, they can be given as smm and rmm."
--
-- That is more complex than below. I cannot fault the original author for just hard coding a table.
function_keys_1 :: ClassifyTable
function_keys_1 =
    let f ff nrs m = [ ("\ESC["++show n++"~",EvKey (KFun $ n-(nrs!!0)+ff) m) | n <- nrs ] in
    concat [f 1 [25,26] [MShift], f 3 [28,29] [MShift], f 5 [31..34] [MShift] ]

-- | VT 100 (?) encoding for meta plus char
--
-- TODO: resolve -
--
-- 1. removed 'ESC' from second list due to duplication with "special_support_keys".
-- 2. removed '[' from second list due to conflict with 7-bit encoding for ESC. Whether meta+[ is
-- the same as ESC should examine km and current encoding.
-- 3. stopped enumeration at '~' instead of '\DEL'. The latter is mapped to KBS by
-- special_support_keys.
function_keys_2 :: ClassifyTable
function_keys_2 = [ ('\ESC':[x],EvKey (KChar x) [MMeta])
                  | x <- '\t':[' ' .. '~']
                  , x /= '['
                  ]

tables :: [ClassifyTable]
tables =
    [ nav_keys_0
    , nav_keys_1
    , nav_keys_2
    , nav_keys_3
    , function_keys_1
    , function_keys_2
    ]

