module Graphics.Vty.Input.Terminfo.XTerm where

import Graphics.Vty.Input.Events

-- | The built in input augmentation for XTerm supports any TERM starting with xterm except those
-- containing 8bit.
supports term_name = "xterm" `isPrefixOf` term_name && !("8bit" `isInfixOf` term_name)

-- | Encoding for navigation keys.
--
-- TODO: This is not the same as the input bytes pulled from teh caps table.
nav_keys_0 :: ClassifyTableV1
nav_keys_0 =
    [ k "G" KNP5
    , k "P" KPause
    , k "A" KUp
    , k "B" KDown
    , k "C" KRight
    , k "D" KLeft
    , k "H" KHome
    , k "F" KEnd
    , k "E" KBegin
    ]
    where k c s = ("\ESC["++c,(s,[]))

-- | VT 100 (?) encoding for shift, meta and ctrl plus arrows/home/end
nav_keys_1 :: ClassifyTableV1
nav_keys_1 =
   [("\ESC[" ++ charCnt ++ show mc++c,(s,m))
    | charCnt <- ["1;", ""], -- we can have a count or not
    (m,mc) <- [([MShift],2::Int), ([MCtrl],5), ([MMeta],3),
               ([MShift, MCtrl],6), ([MShift, MMeta],4)], -- modifiers and their codes
    (c,s) <- [("A", KUp), ("B", KDown), ("C", KRight), ("D", KLeft), ("H", KHome), ("F", KEnd)] -- directions and their codes
   ]

-- | VT 100 (?) encoding for ins, del, pageup, pagedown, home, end
nav_keys_2 :: ClassifyTableV1
nav_keys_2 =
    let k n s = ("\ESC["++show n++"~",(s,[]))
    in zipWith k [2::Int,3,5,6,1,4]
                 [KIns,KDel,KPageUp,KPageDown,KHome,KEnd]

-- | VT 100 (?) encoding for ctrl + ins, del, pageup, pagedown, home, end
nav_keys_3 :: ClassifyTableV1
nav_keys_3 =
    let k n s = ("\ESC["++show n++";5~",(s,[MCtrl]))
    in zipWith k [2::Int,3,5,6,1,4]
                 [KIns,KDel,KPageUp,KPageDown,KHome,KEnd]

-- | VT 100 (?) encoding for shift plus function keys
-- 
-- TODO: I suspect this should be generated by interpretting the terminals use of meta mode:
-- "If the terminal has a ``meta key'' which acts as a shift key, setting the 8th bit of any
-- character transmitted, this fact can be indicated with  km.   Other- wise,  software  will
-- assume that the 8th bit is parity and it will usually be cleared.  If strings exist to turn this
-- ``meta mode'' on and off, they can be given as smm and rmm."
--
-- That is more complex than below. I cannot fault the original author for just hard coding a table.
function_keys_1 :: ClassifyTableV1
function_keys_1 =
    let f ff nrs m = [ ("\ESC["++show n++"~",(KFun (n-(nrs!!0)+ff), m)) | n <- nrs ] in
    concat [f 1 [25,26] [MShift], f 3 [28,29] [MShift], f 5 [31..34] [MShift] ]

-- | VT 100 (?) encoding for meta plus char
--
-- TODO: resolve -
--
-- 1. removed 'ESC' from second list due to duplication with "special_support_keys".
-- 2. removed '[' from second list due to conflict with 7-bit encoding for ESC. Whether meta+[ is
-- the same as ESC should examine km and current encoding.
-- 3. stopped enumeration at '~' instead of '\DEL'. The latter is mapped to KBS by
-- special_support_keys.
function_keys_2 :: ClassifyTableV1
function_keys_2 = [ ('\ESC':[x],(KASCII x,[MMeta])) | x <- '\t':[' ' .. '~'],
                                                      x /= '[']

-- | classify table for ANSI terminals
tables :: [ClassifyTableV1]
tables =
    [ nav_keys_0
    , nav_keys_1
    , nav_keys_2
    , nav_keys_3
    , function_keys_1
    , function_keys_2
    ]

